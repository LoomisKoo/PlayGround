// 声明是Android程序，
//com.android.application 表示这是一个应用程序模块，打包得到的是.apk文件
//com.android.library 标识这是一个库模块，打包得到的是.aar文件
//而这区别：前者可以直接运行，后着是依附别的应用程序运行
apply plugin: 'com.android.application'

//获取打包时间
def releaseTime() {
    return new Date().format("yyyyMMdd HH:mm:ss", TimeZone.getTimeZone("GMT+08"))
}

//这个闭包主要为了配置项目构建的各种属性：
android {
    //设置编译时用的Android版本
    compileSdkVersion 28

    defaultConfig {
        //项目的包名
        applicationId "com.koo.loomis.playground"
        //指定项目最低兼容的版本，如果设备小于这个版本或者大于maxSdkVersion(一般不用)将无法安装这个应用。
        minSdkVersion 21
        //指定项目的目标版本，表示在该目标版本上已经做过充分测试，系统会为该应用启动一些对应该目标系统的最新功能特性，
        //Android系统平台的行为变更，只有targetSdkVersion的属性值被设置为大于或等于该系统平台的API版本时，才会生效。
        //例如，若指定targetSdkVersion值为22，则表示该程序最高只在Android5.1版本上做过充分测试，在Android6.0系统上（对应targetSdkVersion为23）
        //拥有的新特性如系统运行时权限等功能就不会被启用。
        targetSdkVersion 28
        //表示版本号，一般每次打包上线时该值只能增加，打包后看不见。
        versionCode 1
        //表示版本名称，展示在应用市场上。
        versionName "1.0"
        //表明要使用AndroidJUnitRunner进行单元测试
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        flavorDimensions "dev"
        javaCompileOptions { annotationProcessorOptions { includeCompileClasspath = true } }


        configurations {
            all*.exclude group: 'com.google.common.util.concurrent.ListenableFuture'
        }
    }

    compileOptions {

        sourceCompatibility JavaVersion.VERSION_1_8

        targetCompatibility JavaVersion.VERSION_1_8

    }

    //自动化打包配置
    signingConfigs {
        // 线上环境
        release {
            keyAlias 'key'
            keyPassword '111111'
            storeFile file('/Applications/work/Android/StudioProject/PlayGround/app/keyStore.jks')
            storePassword '111111'
        }
        // 开发环境
        debug {
            keyAlias 'key'
            keyPassword '111111'
            storeFile file('/Applications/work/Android/StudioProject/PlayGround/app/keyStore.jks')
            storePassword '111111'
        }
    }

    //这个闭包主要指定生成安装文件的主要配置，一般包含两个子闭包，一个是debug闭包，用于指定生成测试版安装文件的配置，可以忽略不写；
    //另一个是release闭包，用于指定生成正式版安装文件的配置。两者能配置的参数相同，最大的区别默认属性配置不一样，
    buildTypes {
        // 生产环境
        release {
            //配置Log日志
            buildConfigField("boolean", "LOG_DEBUG", "false")
            // 配置URL前缀
            // 用于解决Beta版本服务和Release版本服务地址不同或者一些Log打印需求控制的。
            // 例如：配置buildConfigField("boolean", "LOG_DEBUG", "true")，这个方法接收三个非空的参数，
            // 第一个：确定值的类型，第二个：指定key的名字，第三个：传值，调用的时候BuildConfig.LOG_DEBUG即可调用。
            buildConfigField("String", "URL_PERFIX", "\"https://release.cn/\"")
            //是否对代码进行混淆
            minifyEnabled false
            // 指定混淆的规则文件，这里指定了proguard-android.txt文件和proguard-rules.pro文件两个文件，
            // proguard-android.txt文件为默认的混淆文件，里面定义了一些通用的混淆规则。
            // proguard-rules.pro文件位于当前项目的根目录下，可以在该文件中定义一些项目特有的混淆规则。
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            //指定混淆的规则文件
            //设置签名信息
            // 通过signingConfigs.release或者signingConfigs.debug，配置相应的签名，
            // 但是添加此配置前必须先添加signingConfigs闭包，添加相应的签名信息。
            signingConfig signingConfigs.release
            //是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多
            pseudoLocalesEnabled false
            //是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率
            zipAlignEnabled true
            //在applicationId 中添加了一个后缀，一般使用的不多
            applicationIdSuffix ''
            //在versionName 中添加了一个后缀，一般使用的不多
            versionNameSuffix "palyGround"
            //表示渲染等级，默认是3。
            renderscriptOptimLevel 3
        }
        // 测试环境
        debug {
            //配置Log日志
            buildConfigField("boolean", "LOG_DEBUG", "true")
            // 配置URL前缀
            buildConfigField("String", "URL_PERFIX", "\"https://test.com/\"")
            //是否对代码进行混淆
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            //指定混淆的规则文件
            //设置签名信息
            signingConfig signingConfigs.debug
            //是否支持断点调试
            debuggable true
            //是否可以调试NDK代码
            jniDebuggable true
            //是否开启渲染脚本就是一些c写的渲染方法
            renderscriptDebuggable true
            //是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率
            zipAlignEnabled true
            //是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多
            pseudoLocalesEnabled false
            //在applicationId 中添加了一个后缀，一般使用的不多
            applicationIdSuffix ''
            //在versionName 中添加了一个后缀，一般使用的不多
            versionNameSuffix 'palyGround'
        }
    }

    // 目录指向配置
    // 配置 jniLibs.srcDirs = ['libs']，可以在Android studio的Android视图下生成jniLibs文件夹，
    // 可以方便我们存放jar包和库文件
    sourceSets {
        main {
            //指定lib库目录
            jniLibs.srcDirs = ['libs']
        }
    }

    //打包时的相关配置
    packagingOptions {
        // pickFirsts作用是 当有重复文件时 打包会报错 这样配置会使用第一个匹配的文件打包进入apk
        // 表示当apk中有重复的META-INF目录下有重复的LICENSE文件时  只用第一个 这样打包就不会报错
        pickFirsts = ['META-INF/LICENSE']

        // 当出现重复文件时 合并重复的文件 然后打包入apk
        // 这个是有默认值得 merges = [] 这样会把默默认值去掉  所以我们用下面这种方式 在默认值后添加
        merge 'META-INF/LICENSE'

        // 这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。
        exclude 'META-INF/services/javax.annotation.processing.Processor'
    }

    // 多个渠道配置
    // 这个配置是经常会使用到的，通常在适配多个渠道的时候，需要为特定的渠道做部分特殊的处理，比如设置不同的包名、应用名等。
    // 场景：当我们使用友盟统计时，通常需要设置一个渠道ID，那么我们就可以利用productFlavors来生成对应渠道信息的包

    //    配置完之后，在命令行窗口中（Terminal）中输入gradlew assembleRelease（windows）即可开始打包，
    //    在Mac系统中对应指令应该是./gradlew assembleRelease。当然，如果想要debug版本的包，将指令中assembleRelease改为assembleDebug即可。
    //    最后生成的包还是在app/build/outputs/apk中，默认命名格式如app-wandoujia-release-unsigned.apk，在module的Build Variants中可以选择相应的渠道。
    //    注：Android Studio3.0需在主app的build.gradle里面的
    //    defaultConfig {
    //        targetSdkVersion：***
    //        minSdkVersion ：***
    //        versionCode：***
    //        versionName ：***
    //        // 版本名后面添加一句话，意思就是flavor dimension 它的维度就是该版本号，这样维度就是都是统一的了
    //        flavorDimensions "versionCode"
    //    }
    productFlavors {
        wandoujia {
            // 豌豆荚渠道包配置
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: "wandoujia"]
            // 配置包名
            applicationId "com.koo.loomis.playground.wandoujia"
            //版本名与默认的一致，可不配置
            versionName defaultConfig.versionName
            dimension "dev"
        }
        xiaomi {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: "xiaomi"]
            // 配置包名
            applicationId "com.koo.loomis.playground.xiaomi"
            //版本名与默认的一致，可不配置
            versionName defaultConfig.versionName
            dimension "dev"

        }
        tencent {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: "tencent"]
            //配置包名
            applicationId "com.koo.loomis.playground.tencent"
            //版本名与默认的一致，可不配置
            versionName defaultConfig.versionName
            dimension "dev"
        }
    }

    // 程序在编译的时候会检查lint，有任何错误提示会停止build，我们可以关闭这个开关
    lintOptions {
        //即使报错也不会停止打包
        abortOnError false
        //打包release版本的时候进行检测
        checkReleaseBuilds false
    }

    // 在apk文件后边生成版本号信息
    applicationVariants.all { variant ->
        //批量修改Apk名字
        variant.outputs.all { output ->
            if (variant.buildType.name == 'release') {
                outputFileName = rootProject.getName() + "_v" + defaultConfig.versionName + "_" + productFlavors[0].name + "_" + buildType.name + ".apk"
            } else {
                outputFileName = rootProject.getName() + "_v" + defaultConfig.versionName + "_" + productFlavors[0].name + "_" + buildType.name + "_${releaseTime()}.apk"
            }
        }
    }
}

configurations {
//这里要排除到这个包，这个包会与 com.google.guava 冲突，导致编译不过
    all*.exclude group: 'com.google.guava', module: 'listenablefuture'
}

//该闭包定义了项目的依赖关系，一般项目都有三种依赖方式：
// 本地依赖、库依赖和远程依赖。
// 本地依赖可以对本地的jar包或目录添加依赖关系，
// 库依赖可以对项目中的库模块添加依赖关系，
// 远程依赖可以对jcener库上的开源项目添加依赖关系。
// 从Android Studio3.0后compile引入库不在使用，
// 而是通过api和implementation，api完全等同于以前的compile，
// 用api引入的库整个项目都可以使用，
// 用implementation引入的库只有对应的Module能使用，
// 其他Module不能使用，由于之前的项目统一用compile依赖，导致的情况就是模块耦合性太高，不利于项目拆解，
// 使用implementation之后虽然使用起来复杂了但是做到降低偶合兴提高安全性。
dependencies {
    // 本地jar包依赖
    // 一个本地依赖声明，表示将libs目录下所有.jar后缀的文件都添加到项目的构建路径当中。
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    // 声明测试用例库
    testImplementation 'junit:junit:4.12'
    // 远程依赖
    // 一个标准的远程依赖库格式，
    // 其中com.android.support为域名部分，用于区分不同公司的库；
    // appcompat-v7为组件名称，用于区分同一个公司的不同库；
    // 27.1.1为版本号，用于区分同一个库的不同版本。
    // 加上这句声明后，Gradle在构建项目时会先检查一下本地是否已经缓存过该库，
    // 若没有缓存则自动联网下载，下载后自动添加到项目的构建路径中去。
//    implementation 'androidx.appcompat:appcompat:1.1.0-alpha04'
    implementation 'androidx.constraintlayout:constraintlayout:2.0.0-alpha4'
//    androidTestImplementation 'androidx.test:runner:1.2.0-alpha03'
//    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0-alpha03'
    implementation 'cn.simonlee.widget:swipeback:1.0.14'
    implementation 'org.jetbrains:annotations-java5:15.0'
    //基础库
    implementation 'com.github.LoomisKoo:BaseLibrary:1.1.1'

    implementation 'com.github.LoomisKoo:banner:1.0.5'

//    implementation 'com.google.android.material:material:1.1.0-alpha05'
}
